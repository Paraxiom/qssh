# The QKD Classical TLS Vulnerability

## The Problem

```
QSSH Client ----[Classical TLS]----> QKD Hardware ----[Quantum Channel]----> QKD Peer
     ^                                      ^                                    ^
     |                                      |                                    |
 Quantum-safe                          VULNERABLE!                          Quantum-safe
 (PQC crypto)                    (RSA/ECDSA certificates)                  (QKD photons)
```

**A quantum adversary could:**
1. Break the TLS connection (Shor's algorithm on RSA/ECDSA)
2. Steal QKD keys in transit over HTTPS
3. Defeat the entire purpose of QKD!

## Current Mitigations (Imperfect)

### 1. **Local Network Isolation**
```yaml
# Deploy QKD hardware on isolated network
QKD_Network:
  - No internet access
  - Physical security
  - Air-gapped if possible
```

### 2. **VPN with PSK** (Pre-Shared Key)
```bash
# Use symmetric key (quantum-safe) instead of PKI
openvpn --secret quantum-safe-psk.key
```

### 3. **Direct Fiber Connection**
```
QSSH Server ←——[Dedicated Fiber]——→ QKD Device
            No IP network = No TLS
```

## Proposed Solutions

### Solution 1: Post-Quantum TLS Proxy
```
                 ┌─────────────────┐
                 │  PQ-TLS Proxy   │
QSSH ←--PQC--→   │                 │  ←--Classical TLS--→ QKD Device
                 │ Kyber + SPHINCS │
                 └─────────────────┘
```

Implementation:
```rust
// Proxy that upgrades classical TLS to post-quantum
pub struct QuantumTlsProxy {
    // Listen with PQ-TLS
    pq_listener: PqTlsListener,
    // Connect with classical TLS to QKD
    classic_client: TlsClient,
}

impl QuantumTlsProxy {
    pub async fn forward_request(&self, pq_request: Request) -> Result<Response> {
        // Receive over quantum-safe connection
        let decrypted = self.pq_listener.decrypt(pq_request)?;
        
        // Forward over classical TLS (on local network only!)
        let response = self.classic_client.send(decrypted).await?;
        
        // Return over quantum-safe connection
        self.pq_listener.encrypt_response(response)
    }
}
```

### Solution 2: Hardware Security Module Bridge
```
QSSH ←--→ HSM ←--[Local Bus/PCIe]--→ QKD Hardware
         (Contains pre-shared keys)
```

The HSM:
- Stores symmetric keys shared with QKD device
- No TLS needed, just symmetric encryption
- Physical security for key storage

### Solution 3: Quantum-Safe Tunneling Protocol
```rust
// Custom protocol using only symmetric crypto
pub struct QkdSymmetricTunnel {
    // 256-bit key pre-shared during installation
    psk: [u8; 32],
    // Counter for nonce generation
    counter: u64,
}

impl QkdSymmetricTunnel {
    pub fn encrypt_request(&mut self, request: &[u8]) -> Vec<u8> {
        // Use ChaCha20-Poly1305 with PSK
        let nonce = self.generate_nonce();
        let ciphertext = chacha20poly1305::encrypt(&self.psk, &nonce, request);
        self.counter += 1;
        ciphertext
    }
}
```

### Solution 4: Wait for QKD Vendor Updates

ETSI is working on post-quantum TLS for QKD:
- ETSI TS 103 744: QKD Protocol Security
- Vendors (Toshiba, IDQ) will eventually upgrade
- But this could take years...

## Recommended Approach for QSSH

**Short term (Now):**
1. Deploy PQ-TLS proxy on same machine as QKD hardware
2. Use localhost connection (harder to intercept)
3. Add authentication beyond TLS (application-level tokens)

**Medium term:**
1. Work with QKD vendors to implement post-quantum TLS
2. Develop standard for PQC in ETSI QKD APIs
3. Hardware security module integration

**Long term:**
1. QKD devices with built-in post-quantum crypto
2. Direct quantum channel access (no classical layer)
3. Fully quantum network stack

## Code Example: Localhost Hardening

```rust
// Force QKD connection through localhost only
pub struct HardenedQkdClient {
    client: QkdClient,
}

impl HardenedQkdClient {
    pub fn new(qkd_port: u16) -> Result<Self> {
        // ONLY accept localhost connections
        let endpoint = format!("https://127.0.0.1:{}", qkd_port);
        
        // Additional checks
        if !is_running_on_same_machine() {
            return Err("QKD must be on same machine");
        }
        
        // Use Unix domain sockets if possible (no network stack)
        #[cfg(unix)]
        if let Ok(sock) = UnixStream::connect("/var/run/qkd.sock") {
            return Ok(Self::from_unix_socket(sock));
        }
        
        Ok(Self {
            client: QkdClient::new(&endpoint, None)?,
        })
    }
}
```

## The Ugly Truth

Until QKD vendors implement post-quantum TLS, there's a window of vulnerability. The best we can do is:

1. **Minimize attack surface** (localhost, isolated networks)
2. **Add layers** (PSK + TLS, not just TLS)
3. **Monitor for quantum attacks** (would need physical presence for localhost)
4. **Plan for rapid key rotation** (limit exposure time)

The irony: We need quantum-safe communication to access our quantum-safe keys!